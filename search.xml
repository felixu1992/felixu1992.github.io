<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一次重构引发的对 Static 的探讨</title>
      <link href="/2021/07/05/Uncategorized-2021-07-05-%E4%B8%80%E6%AC%A1%E9%87%8D%E6%9E%84%E5%BC%95%E5%8F%91%E7%9A%84%E5%AF%B9Static%E7%9A%84%E6%8E%A2%E8%AE%A8/"/>
      <url>/2021/07/05/Uncategorized-2021-07-05-%E4%B8%80%E6%AC%A1%E9%87%8D%E6%9E%84%E5%BC%95%E5%8F%91%E7%9A%84%E5%AF%B9Static%E7%9A%84%E6%8E%A2%E8%AE%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h1><p>这次的问题源起于我要做一次手动参数校验，这在 <em>Spring Boot</em> 中，我们可以使用 <em>SmartValidator</em> 来进行，当有较多的地方需要做类似的操作，确实可以考虑将这手动校验的逻辑进行封装，而这次重构也正是基于其他同学的封装展开的，下面我们可以看一下相关代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartValidateUtil</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SmartValidator smartValidator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validateAnnotation</span><span class="params">(Object object, String name)</span> <span class="keyword">throws</span> BindException </span>&#123;</span><br><span class="line">        checkSmartValidator();</span><br><span class="line">        BeanPropertyBindingResult result = <span class="keyword">new</span> BeanPropertyBindingResult(object, name);</span><br><span class="line">        smartValidator.validate(object, result);</span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindException(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkSmartValidator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (smartValidator == <span class="keyword">null</span>)</span><br><span class="line">            smartValidator = ApplicationUtils.getBean(SmartValidator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有兴趣的可以思考一下有多少不合理的地方，这里便于理解，也给出 <em>ApplicationUtils#getBean(Class<t> type)</t></em> 的相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationUtils</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(@NonNull ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        context = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Bean 的名称获取 Bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Bean 的类型获取 Bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getBean(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>这里我依次罗列我认为有问题的地方，后续也会给出重构之后的代码，如果有不合理的地方，也欢迎指出：</p><ol><li>既然作为工具类了，<em>Spring</em> 的注解在这里就显得突兀了；</li><li>变量的访问限定符；</li><li>屏蔽了原有的分组校验功能，限制功能，这不合适；</li><li>静态变量用静态方法初始化的逻辑画蛇添足(这也是争论最多的地方了)。</li></ol><p>在进行重构之后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartValidateUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SmartValidator SMART_VALIDATOR = ApplicationUtils.getBean(SmartValidator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, String name, Object... validationHints)</span> <span class="keyword">throws</span> BindException </span>&#123;</span><br><span class="line">        BeanPropertyBindingResult result = <span class="keyword">new</span> BeanPropertyBindingResult(target, name);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(validationHints) || validationHints.length == <span class="number">0</span>)</span><br><span class="line">            SMART_VALIDATOR.validate(target, result);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            SMART_VALIDATOR.validate(target, result, validationHints);</span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindException(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, String name)</span> <span class="keyword">throws</span> BindException </span>&#123;</span><br><span class="line">        validate(target, name, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前三点我觉得应该算是很容易理解的点了，真正的争论在于第四点。</p><p>从代码中可以知道，这个 <em>SmartValidator</em> 来源于 <em>Spring</em> 的容器，很多人觉得原来的写法合理，理由如下：</p><p>静态变量初始化的时候，<em>Spring</em> 的容器尚未启动，此时使用 <em>ApplicationUtils.getBean</em> 进行赋值，结果肯定会是 <em>null</em>，所以使用静态方法，在使用的时候去判断一次，如果是 <em>null</em>，再去容器中获取完成赋值，此时容器已经启动完成了，也就不会再为 <em>null</em> 了。而我的写法中，直接赋值，肯定会是 <em>null</em>。</p><p>然而，实际情况真的是这样吗。</p><p>这里的关键其实只有一点被 <em>static</em> 修饰的变量，它是在什么时候初始化的？这其实是个很基础的问题，然而在我们日常使用的时候却常常被忽略。</p><p>只要知道这个问题的答案，那么也就知道了我重构的依据，那么是什么时候初始化的呢，<em>static</em> 修饰的变量，在类第一次被显示使用的时候初始化(这里不会展开去说，有兴趣的可以自己找相关文章)。所以这里真正会发生什么呢？</p><p>在整个 <em>Spring</em> 容器的启动过程中，<em>ApplicationUtils.getBean(SmartValidator.class)</em> 压根没有执行，此时的 <em>SMART_VALIDATOR</em> 只是分配了默认的零值，所以也就不存在从容器中获取不到而赋值为 <em>null</em> 的情况，而当代码中第一次使用 <em>SmartValidateUtil#validate()</em> 时，<em>SMART_VALIDATOR</em> 才会真正的去初始化，也就是此时 <em>ApplicationUtils.getBean(SmartValidator.class)</em> 执行，而此时 Spring 的容器一定是正常启动完成了，所以此时 <em>getBean</em> 得到的结果其实与原写法中的判断之后再赋值的结果是一致的。</p><p>这便是我认为使用静态方法判断之后再去赋值是脱裤子放屁多此一举的依据。</p><p>当然这个是可以验证的，你可以在 <em>ApplicationUtils#getBean(Class<t> type)</t></em> 的逻辑中输出当前的入参，观察它什么时候输出的，很容易验证它在第一次使用 <em>SmartValidateUtil</em> 时执行的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><em>Static</em> 作为一个日常编码中十分常用的一个关键字，本来关于他的相关知识也十分基础，但是在实际的使用过程中，真的有注意他的一些特性吗，恐怕也并非如此。由此可见，日常编码过程中，可能还是缺乏一些对代码的思考。这个讨论在我重构完之后，在组内讨论过，同时也在一个技术交流群中讨论过，然而不乏一些经验丰富的人同样会搞错，能第一时间 <em>Get</em> 到点的人很少很少，但是等说到 <em>Static</em> 什么时候初始化的，大家都懂。其实想表达什么呢，无非：</p><ol><li>写代码不是想当然的，严谨的看问题固然好，但是也不要画蛇添足嘛，对于不确定的问题，大可以写段代码验证一下；</li><li>适当封装是合理的，但是若非必要，不要屏蔽原有功能，降低可用性；</li><li>写代码之前尽量做到心里大致有数，不要搞的四不像，不能代码写了，以后还要被说这是哪个沙雕写的代码啊。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Uncategorized </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Java </tag>
            
            <tag> Static </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同时使用 Quartz 和 Websocket 报错分析</title>
      <link href="/2020/12/16/Uncategorized-2020-12-16-%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8spring-boot-starter-quartz%E5%92%8Cspring-boot-starter-websocket%E6%8A%A5%E9%94%99/"/>
      <url>/2020/12/16/Uncategorized-2020-12-16-%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8spring-boot-starter-quartz%E5%92%8Cspring-boot-starter-websocket%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在同事负责的 <em>Spring Boot</em> 项目中，同时使用了 <em>spring-boot-starter-quartz</em> 和 <em>spring-boot-starter-websocket</em> 两个 <em>jar</em> 包依赖，创建了定时任务，这时候项目无法启动，起初这个问题是同事在项目中发现的，<em>Google</em> 了一下也就解决了这个问题，但是解决这个 <em>Bug</em> 的帖子很多，但是却没有提及为什么会出现此情况，遂问我能不能帮他看看原因，撸了一下源码后便有了此文。</p><h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>首先来看一下启动过程中的报错吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">2020-12-08 18:50:09.535 [main] ERROR org.springframework.boot.SpringApplication [line:837] - Application run failed</span><br><span class="line">org.springframework.beans.factory.BeanNotOfRequiredTypeException: Bean named 'defaultSockJsTaskScheduler' is expected to be of type 'org.springframework.scheduling.TaskScheduler' but was actually of type 'org.springframework.beans.factory.support.NullBean'</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:399)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:227)</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1175)</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1142)</span><br><span class="line">at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.resolveSchedulerBean(ScheduledAnnotationBeanPostProcessor.java:327)</span><br><span class="line">at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.finishRegistration(ScheduledAnnotationBeanPostProcessor.java:256)</span><br><span class="line">at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.onApplicationEvent(ScheduledAnnotationBeanPostProcessor.java:233)</span><br><span class="line">at org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor.onApplicationEvent(ScheduledAnnotationBeanPostProcessor.java:105)</span><br><span class="line">at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)</span><br><span class="line">at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)</span><br><span class="line">at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:404)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:361)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:898)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:554)</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:143)</span><br><span class="line">at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:758)</span><br><span class="line">at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:750)</span><br><span class="line">at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:397)</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:315)</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1237)</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1226)</span><br></pre></td></tr></table></figure><p>我们从报错入手，<em>BeanNotOfRequiredTypeException</em> 显然是 <em>Bean</em> 的类型不对，然后我们再具体看名称叫 <em>defaultSockJsTaskScheduler</em> 的 <em>Bean</em> 类型不对，那搜索大法，先分别从 <em>@EnableWebSocket</em> 和 <em>@EnableScheduling</em> 点进行，把这两个包的源码下载了再说，然后全局搜索 <em>defaultSockJsTaskScheduler</em>，这时候找定义叫 <em>defaultSockJsTaskScheduler</em> 的，很容易定位到 <em>WebSocketConfigurationSupport<a href="#quote-1"><sup>1</sup></a></em> 如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TaskScheduler <span class="title">defaultSockJsTaskScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initHandlerRegistry().requiresTaskScheduler()) &#123;</span><br><span class="line">        ThreadPoolTaskScheduler threadPoolScheduler = <span class="keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">        threadPoolScheduler.setThreadNamePrefix(<span class="string">"SockJS-"</span>);</span><br><span class="line">        threadPoolScheduler.setPoolSize(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        threadPoolScheduler.setRemoveOnCancelPolicy(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.scheduler = threadPoolScheduler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.scheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一个关键点，我们来具体看一下这里的逻辑，如果这个 <em>if</em> 条件不满足，这里将返回 <em>null</em>，也就是会创建一个 <em>NullBean</em> 在容器中作为 <em>TaskScheduler</em>。</p><p>经过以上步骤我们找到了 <em>NullBean</em> 产生的地方，那么为什么单独使用两个包都不会有问题呢，只能解释，当单独使用 <em>spring-boot-starter-websocket</em> 时，即使创建了 <em>NullBean</em> 但是实际并不会被使用，而增加 <em>spring-boot-starter-quartz</em> 的过程肯定使用到了 <em>TaskScheduler</em>。而单独使用 <em>spring-boot-starter-quartz</em> 又没有问题，所以可以猜想肯定还有地方实例化了 <em>TaskScheduler</em>，那么进入 <em>TaskScheduler</em>，然后来看看那些地方用到了它：</p><p><img src="https://oss-blog.felixu.top/TaskScheduler%E5%BC%95%E7%94%A8.png" alt="TaskScheduler引用"></p><p>很容易可以猜到 <em>TaskSchedulingAutoConfiguration</em>，我们进去看到了如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(&#123; SchedulingConfigurer<span class="class">.<span class="keyword">class</span>, <span class="title">TaskScheduler</span>.<span class="title">class</span>, <span class="title">ScheduledExecutorService</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ThreadPoolTaskScheduler</span> <span class="title">taskScheduler</span>(<span class="title">TaskSchedulerBuilder</span> <span class="title">builder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上定位，其实我们已经找到了问题了，这里我们来总结一下，单独有 <em>spring-boot-starter-websocket</em> 时，会创建 <em>defaultSockJsTaskScheduler</em>，但是没地方用到，所以不会有问题，而引入 <em>spring-boot-starter-quartz</em> 时，由于前面产生的 <em>NullBean</em> 导致这个条件装配失效，所以不会产生合适的 <em>TaskScheduler</em> 实例。由于 <em>@EnableScheduling</em> 的存在，导致 <em>ScheduledAnnotationBeanPostProcessor<a href="#quote-2"><sup>2</sup></a></em> 类中的 <em>finishRegistration</em> 方法会被执行到，为啥不用细说了吧(不明白可以截图找我问)，此时该方法中会执行 <em>this.registrar.setTaskScheduler(resolveSchedulerBean(this.beanFactory, TaskScheduler.class, false));</em> 这串代码，这里的 <em>resolveSchedulerBean</em> 将会去容器中找 <em>TaskScheduler</em> 的实例，通过名称找到了 <em>defaultSockJsTaskScheduler</em>，但是他的类型却是个  <em>NullBean</em> 此时就会触发上述错误。</p><p>这便是导致这个 <em>Bug</em> 的原因了，有些人可能疑惑，你上面那些类咋知道的，<em>emmmm</em>，其实是猜的，找这种问题一般步骤就是<strong>猜想、验证</strong>。所以先猜，再去 <em>Debug</em> 验证。</p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>既然已经知道了为什么会出现这个错了，就容易修复了，就是因为存在了一个 <em>NullBean</em> 类型的 <em>TaskScheduler</em> 实例，在查找的时候出现了该错误，那么我们只需要自己创建一个正确类型就好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ThreadPoolTaskScheduler <span class="title">taskScheduler</span><span class="params">(TaskSchedulerBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，根据前面提到的 <em>if</em> 条件不满足才会出现 <em>NullBean</em>，那么自然还有种方案，那就是让 <em>if</em> 条件满足，即实现一个 <em>WebSocketConfigurer</em> 也可以解决这个问题(看一下 <em>if</em> 附近的注释，实现应该不难，就不给案例了)。</p><p>第一种方案也是搜索引擎能找到的解决方案了，这里只是探究了一下这个错误的前因后果，问题解决，愉快的告诉同事咋回事就完事了。</p><h1 id="一点思考"><a href="#一点思考" class="headerlink" title="一点思考"></a>一点思考</h1><p>然而，此时突然萌生了另一个想法。这不应该是 <em>Spring Framework</em> 的 <em>Bug</em> 吗，虽然在几个使用 <em>TaskScheduler</em> 的地方都说明可以为 <em>null</em>，但是可以为 <em>null</em> 和创建了一个 <em>NullBean</em> 类型作为 <em>TaskScheduler</em> 的实例，并导致了真正在使用的时候产生了错误，这肯定是 <em>Spring Framework</em> 的 <em>Bug</em> 啊。</p><p>在继续翻看了源码中的版本信息，可以了解到该问题应该已经存在数个版本了，在网上也有不少关于这个错误的处理方案，那么为什么官方却迟迟没有解决这个问题呢，难道是官方一直没有发现这个 <em>Bug</em>，也不是没有这个可能，又花了点时间去搜索了一遍 <em>issue</em> 发现确实没有相关问题。</p><p>既然已经确定这肯定是 <em>Spring Framework</em> 本身的 <em>Bug</em> 了，且没有相关 <em>issue</em> 那我就自己提一个吧。</p><p>于是便有了 <em><a href="https://github.com/spring-projects/spring-boot/issues/24448" target="_blank" rel="noopener">use spring-boot-starter-quartz and spring-boot-starter-websocket simultaneously</a></em> 这个 <em>issue</em>，提完之后，官方回复的很快，就是过程有点曲折，一开始可能认为是 <em>Spring Boot</em> 的问题，所以被迁移了过去，然后经过讨论后又被迁回了 <em>Spring Framework</em> 下。</p><p>在确定属于 <em>Spring Framework</em> 的问题后，又重开了一个新的 <em><a href="https://github.com/spring-projects/spring-framework/issues/26271" target="_blank" rel="noopener">Consistent type resolution handling for NullBean</a></em> 并进行了后续修复。据说会在 <em>5.3.3</em> 中处理掉该问题。所以之后的版本就不需要我们再去处理这个问题了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>找问题应该要多去猜想验证，不能为了解决问题而解决问题；</li><li>敢于质疑，不论对于 <em>Spring Framework</em> 还是对于其他大佬(现在很多大 <em>V</em> 写的文章也存在错误)，不能一味相信，要有自己的判断力。</li></ol><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ol><li><em><div id="quote-1">org.springframework.web.socket.config.annotation.WebSocketConfigurationSupport</div></em></li><li><em><div id="quote-2">org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor</div></em></li></ol>]]></content>
      
      
      <categories>
          
          <category> Uncategorized </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Quartz </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调整多个 @ControllerAdvice 的执行顺序</title>
      <link href="/2020/04/18/Uncategorized-2020-04-18-%E8%B0%83%E6%95%B4%E5%A4%9A%E4%B8%AAControllerAdvice%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
      <url>/2020/04/18/Uncategorized-2020-04-18-%E8%B0%83%E6%95%B4%E5%A4%9A%E4%B8%AAControllerAdvice%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h1><ul><li><em>Spring Boot</em> 版本为 <em>2.0.9.RELEASE</em></li><li><em>Spring Framework</em> 对应版本为 <em>5.0.13.RELEASE</em></li></ul><p><strong>不同版本间可能存在差异，需要看清楚所使用的版本</strong></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>问题起源于在公司内部，我们创建了自己的自定义 <em>web</em> 模块的 <em>stater</em>，在其中有统一的异常处理，普通的异常处理我们称之为 <em>ExceptionResolver</em>，还有一种我们称之为 <em>FeignExceptionResolver</em>，专门为了处理 <em>FeignException</em>，为啥会单独写一个处理 <em>FeignException</em> 呢，主要是考虑到可能有的模块会没有引入 <em>Feign</em> 的包，从而造成启动报错。而这个在近期又出现了另一个问题，就是当别的一些同学乱来，在自己的应用上乱指定 <em>scanBasePackages</em> 导致这两个 <em>Resolver</em> 的加载顺序被打乱了，从而导致 <em>FeignException</em> 被普通异常中的搂底操作所处理，造成提示错误。<strong>当环境中有多个 <em>@ControllerAdvice</em> 或者 <em>@RestControllerAdvice</em> 注解标注的类，它们是有优先级顺序的，排在前面的先执行</strong>。</p><h1 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h1><p>描述清楚了问题，那就想着怎么去处理它，既然说是加载顺序造成的错误，那么我们应该想到那就需要去调整其加载顺序，而此时自然而然会想到 <em>@Order</em>，由于我们使用的自定义 <em>starter</em>，所以这些类均使用 <em>@Bean</em> 在 <em>spring.factories</em> 文件指向的类中去完成被 <em>Spring</em> 的管理，所以我们做了以下尝试：</p><ul><li>在 <em>@Bean</em> 处使用 <em>@Order</em>，结果发现无效</li><li>让标注 <em>@ControllerAdvice</em> 或者 <em>@RestControllerAdvice</em> 的类实现 <em>Ordered</em> 接口，无效</li><li>在标注 <em>@ControllerAdvice</em> 或者 <em>@RestControllerAdvice</em> 的类上标注 <em>@Order</em>，成功解决问题</li></ul><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>按理说，一般情况下 <em>@Order</em> 和实现 <em>Ordered</em> 接口的效果应该是一样的，那么这里究竟是哪里出了问题呢，我们从源码入手。</p><h2 id="一脚入坑"><a href="#一脚入坑" class="headerlink" title="一脚入坑"></a>一脚入坑</h2><p>首先我们通过查找 <em>@ControllerAdvice</em> 在哪些地方被用到，很容易观察到其应该被 <em>ExceptionHandlerExceptionResolver</em> 所处理，再观察其变量，我们看到有这样一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ControllerAdviceBean, ExceptionHandlerMethodResolver&gt; exceptionHandlerAdviceCache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>这个数据结构也表明了，多个同时存在时应该是有优先级顺序的。</p><p>接下来我们查找这个变量被设置值的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initExceptionHandlerAdviceCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplicationContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Looking for exception mappings: "</span> + getApplicationContext());</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 2. put 前的参数来源</span></span><br><span class="line">    List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());</span><br><span class="line">    <span class="comment">// 3. 对多个 ControllerAdviceBean 进行排序</span></span><br><span class="line">    AnnotationAwareOrderComparator.sort(adviceBeans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ControllerAdviceBean adviceBean : adviceBeans) &#123;</span><br><span class="line">      Class&lt;?&gt; beanType = adviceBean.getBeanType();</span><br><span class="line">      <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unresolvable type for ControllerAdviceBean: "</span> + adviceBean);</span><br><span class="line">&#125;</span><br><span class="line">      ExceptionHandlerMethodResolver resolver = <span class="keyword">new</span> ExceptionHandlerMethodResolver(beanType);</span><br><span class="line">      <span class="keyword">if</span> (resolver.hasExceptionMappings()) &#123;</span><br><span class="line">        <span class="comment">// 1. 变量被设置值</span></span><br><span class="line">        <span class="keyword">this</span>.exceptionHandlerAdviceCache.put(adviceBean, resolver);</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">          logger.info(<span class="string">"Detected @ExceptionHandler methods in "</span> + adviceBean);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ResponseBodyAdvice<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanType</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseBodyAdvice.add(adviceBean);</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">          logger.info(<span class="string">"Detected ResponseBodyAdvice implementation in "</span> + adviceBean);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到 <em>Map</em> 被设置值的地方为 <em>1</em> 处，而它的参数来源于 <em>2</em> 处，在 <em>2</em> 处查找了所有标注 <em>@ControllerAdvice</em> 或者 <em>@RestControllerAdvice</em> 的类为 <em>ControllerAdviceBean</em> 的 <em>List</em> 集合，后在 <em>3</em> 对其进行排序。</p><p>在找到这部分的源码，<em>emmmm</em> 一脚就踩坑里了，下意识以为直接看 <em>3</em> 中的实现，即可找到原因，好了，就默默追踪 <em>3</em> 吧，其调用方法为 <em>AnnotationAwareOrderComparator.sort(adviceBeans);</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      list.sort(INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在于 <em>INSTANCE</em> 即 <em>public static final AnnotationAwareOrderComparator INSTANCE &#x3D; new AnnotationAwareOrderComparator();</em> 那么具体其实还得看父类中 <em>compare</em> 方法的实现，这里既然能丢给 <em>list.sort</em> 方法，那么必然实现了 <em>Comparator</em> 接口中的 <em>compare</em> 方法，追踪发现这里又调用了父类 <em>OrderComparator</em> 中的 <em>doCompare</em> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doCompare</span><span class="params">(@Nullable Object o1, @Nullable Object o2, @Nullable OrderSourceProvider sourceProvider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> p1 = (o1 <span class="keyword">instanceof</span> PriorityOrdered);</span><br><span class="line">    <span class="keyword">boolean</span> p2 = (o2 <span class="keyword">instanceof</span> PriorityOrdered);</span><br><span class="line">    <span class="keyword">if</span> (p1 &amp;&amp; !p2) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p2 &amp;&amp; !p1) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i1 = getOrder(o1, sourceProvider);</span><br><span class="line">    <span class="keyword">int</span> i2 = getOrder(o2, sourceProvider);</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这里的代码我们可以看到其实现应该在 <em>getOrder</em> 方法中，那么再次往下看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">(@Nullable Object obj, @Nullable OrderSourceProvider sourceProvider)</span> </span>&#123;</span><br><span class="line">    Integer order = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; sourceProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Object orderSource = sourceProvider.getOrderSource(obj);</span><br><span class="line">      <span class="keyword">if</span> (orderSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (orderSource.getClass().isArray()) &#123;</span><br><span class="line">          Object[] sources = ObjectUtils.toObjectArray(orderSource);</span><br><span class="line">          <span class="keyword">for</span> (Object source : sources) &#123;</span><br><span class="line">            order = findOrder(source);</span><br><span class="line">            <span class="keyword">if</span> (order != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          order = findOrder(orderSource);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (order != <span class="keyword">null</span> ? order : getOrder(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，真正的实现又在 <em>findOrder</em> 方法中实现，不得不说，<em>Spring</em> 的源码永远是如此绕，啊啊啊啊啊，蛋疼，继续往下点吧这里会先调用子类 <em>AnnotationAwareOrderComparator</em> 的 <em>findOrder</em> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Integer <span class="title">findOrder</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check for regular Ordered interface</span></span><br><span class="line">    Integer order = <span class="keyword">super</span>.findOrder(obj);</span><br><span class="line">    <span class="keyword">if</span> (order != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for @Order and @Priority on various kinds of elements</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">      <span class="keyword">return</span> OrderUtils.getOrder((Class&lt;?&gt;) obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">      Order ann = AnnotationUtils.findAnnotation((Method) obj, Order<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ann.value();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> AnnotatedElement) &#123;</span><br><span class="line">      Order ann = AnnotationUtils.getAnnotation((AnnotatedElement) obj, Order<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ann.value();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      order = OrderUtils.getOrder(obj.getClass());</span><br><span class="line">      <span class="keyword">if</span> (order == <span class="keyword">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> DecoratingProxy) &#123;</span><br><span class="line">        order = OrderUtils.getOrder(((DecoratingProxy) obj).getDecoratedClass());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就会发现它第一句注释，其实就是检查了是否实现 <em>Ordered</em> 接口，我们点过去瞅瞅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Integer <span class="title">findOrder</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj <span class="keyword">instanceof</span> Ordered ? ((Ordered) obj).getOrder() : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，心里就开始心生疑惑，咦，这不就是如果这个类实现了 <em>Ordered</em> 接口重写了 <em>getOrder</em> 方法，这里就应该会被调用，完成排序啊，那为啥不生效，当时心里是懵逼的，这咋回事！！！</p><h2 id="重头来过"><a href="#重头来过" class="headerlink" title="重头来过"></a>重头来过</h2><p>在懵逼了一会之后，想想还是得回到 <em>ExceptionHandlerExceptionResolver</em> 的 <em>initExceptionHandlerAdviceCache</em> 方法重新开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initExceptionHandlerAdviceCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="comment">// 2. put 前的参数来源</span></span><br><span class="line">    List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());</span><br><span class="line">    <span class="comment">// 3. 对多个 ControllerAdviceBean 进行排序</span></span><br><span class="line">    AnnotationAwareOrderComparator.sort(adviceBeans);</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到这里，对着这两行代码发了会呆，我终于治好了我的瞎，他排序的是 <em>ControllerAdviceBean</em> 那么它其中是不是做了一些处理，这时候我们点开 <em>ControllerAdviceBean</em> 类康康</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerAdviceBean</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> order;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the order value extracted from the &#123;<span class="doctag">@link</span> ControllerAdvice&#125;</span></span><br><span class="line"><span class="comment">     * annotation, or &#123;<span class="doctag">@link</span> Ordered#LOWEST_PRECEDENCE&#125; otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">initOrderFromBean</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (bean <span class="keyword">instanceof</span> Ordered ? ((Ordered) bean).getOrder() : initOrderFromBeanType(bean.getClass()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">initOrderFromBeanType</span><span class="params">(@Nullable Class&lt;?&gt; beanType)</span> </span>&#123;</span><br><span class="line">      Integer order = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        order = OrderUtils.getOrder(beanType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (order != <span class="keyword">null</span> ? order : Ordered.LOWEST_PRECEDENCE);</span><br><span class="line">    &#125;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉无用内容我们看到了这些，它实现了 <em>Ordered</em> 接口，且有个 <em>order</em> 字段，而重写的 <em>getOrder</em> 方法返回为当前这个 <em>order</em> 字段的值，而上面踩坑部分，也不能说一定用没有，至少连贯起来能知道最终排序其实就是排序多个 <em>@ControllerAdvice</em> 或者 <em>@RestControllerAdvice</em> 标注的类生成的 <em>ControllerAdviceBean</em> 中 <em>order</em> 字段的值，而它的来源又是什么呢，就是上面 <em>initOrderFromBeanType</em> 方法中 *OrderUtils.getOrder(beanType)*，好了，感觉快见到真相了。</p><h2 id="柳暗花明"><a href="#柳暗花明" class="headerlink" title="柳暗花明"></a>柳暗花明</h2><p>打开 <em>OrderUtils#getOrder</em> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">getOrder</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    Object cached = orderCache.get(type);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (cached <span class="keyword">instanceof</span> Integer ? (Integer) cached : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Order order = AnnotationUtils.findAnnotation(type, Order<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Integer result;</span><br><span class="line">    <span class="keyword">if</span> (order != <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = order.value();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      result = getPriority(type);</span><br><span class="line">    &#125;</span><br><span class="line">    orderCache.put(type, (result != <span class="keyword">null</span> ? result : NOT_ANNOTATED));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>emmmm</em> 这里就发现极其简单了，就找了这个标注 <em>@ControllerAdvice</em> 或者 <em>@RestControllerAdvice</em> 上有没有标注 <em>@Order</em> 注解，或者是 <em>@Priority</em> 注解，并没有检查有没有实现 <em>Ordered</em> 接口，故而无效，单单只检查了类上有无这俩注解。看到这里也总算是搞明白了这个 <em>Bug</em>。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul><li>修复 <em>Bug</em> 的同时如果有时间还是得明白其中发生了些啥</li><li>如果有规范就按规范来吧，不要瞎胡来，此 <em>Bug</em> 就是由于同学瞎胡来，导致我们得改通用的 <em>starter</em> 来帮他们修复问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> Uncategorized </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
